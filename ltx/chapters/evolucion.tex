
%************************************************
\chapter{Cómputo Evolutivo}\label{ch:evolucion}
%************************************************

% ============================================================
\section{Introducción a Cómputo Evolutivo}
% ============================================================

El \gls{Cómputo Evolutivo} es una rama de la Inteligencia Artificial que se define
por los tipos de algoritmos en los que se enfoca. Son algoritmos que utilizan
el concepto de la selección natural para resolver problemas de cómputo. Son
problemas de optimización en el sentido matemático. Es decir, se concentran en
encontrar un máximo local o un mínimo local utilizando heurísticas.


% ============================================================
\section{Algoritmos Evolutivos}
% ============================================================

Las características que los Algoritmos Evolutivos tienen en común son:

\begin{itemize}
\item Definen una población
\item Definen una función de selección.
\item Utilizan mutación y reproducción junto con la función de selección para
mejorar la población a lo largo de varias generaciones.
\end{itemize}

Aunque comparten la misma idea, se definen distintos tipos de algoritmos con
respecto a la manera en que concretizan estas características.

\begin{itemize}
\item La \emph{Programación Genética} \cite{GenProg} tiene conjuntos de
programas como su población. Su función de selección es la capacidad de un
programa para resolver cierto problema. Los programas se representan como
árboles de sintaxis, y de esta manera se define la mutación y reproducción como
operaciones en árboles.
\item La \emph{Programación Evolutiva} es similar a la Programación Genética
pero lo que se evoluciona son los parámetros de los programas, no su
estructura.
\item Los \emph{Algoritmos Genéticos} definen genotipos y su correspondiente
función de selección que evalúa los fenotipos respectivos. Es decir, se opera
sobre el cromosoma pero se evalúa el organismo.

El algoritmo desarrollado entra dentro de la clasificación de Algoritmo
Genético. El fenotipo es una tabla de cuantificación y el genotipo es un
codificador \gls{JPEG} que usa esa tabla.

\end{itemize}

% ============================================================
\section{Método para la evolución de codificadores JPEG}
% ============================================================

\subsection{Población}

Se inicializa una población de tablas. En el conjunto se incluye la tabla que
tiene todos sus coeficientes iguales a 1, denominada \emph{\gls{tabla
unitaria}}. La tabla unitaria es la que obtiene la mejor calidad posible pero
resulta en menor compresión. El resto del conjunto se llena de tablas con
valores aleatorios entre 1 y 64.

La función de selección requiere de un punto de referencia. Antes de iniciar la
evolución, se comprime la imagen con la tabla unitaria, dándonos un punto de
referencia para la calidad óptima y para el máximo tamaño.

\subsection{Selección}

La calidad de la compresión se determina haciendo una decodificación y
comparando la imagen resultante con la original píxel por píxel. Las
diferencias absolutas se suman. No se utiliza MSE (Error cuadrático medio) por
la enorme cantidad de pixeles y la sensibilidad del algoritmo a errores de
precisión. En lugar de implementar un decodificador JPEG, se incluye un paso de
decodificación en la función principal de procesamiento de bloques. Los
detalles de este proceso se explican en el capítulo \ref{ch:implementacion}.

El tamaño es más fácil de comparar que la calidad de la imagen. Tan solo es
necesario ver cuántos bits pesa la imagen resultante comparada con el tamaño
máximo que se obtiene de la tabla unitaria.

Tenemos dos garantías. Cualquier tabla de cuantificación comparada con la
unitaria va a resultar en mayor compresión y en menor calidad, siempre y cuando
la tabla a comparar no sea en sí una tabla unitaria.

Sea $T$ una tabla de nuestra población y sea $T_0$ la tabla unitaria.

Definimos nuestra función de selección como:

\begin{equation}
f(T) = \frac{e(T)}{e(T_0)} + \alpha \Big(1 + \frac{s(T)}{s(T_0)}\Big)
\end{equation}\label{eq:fitness}

\dots donde $e(T)$ es el error de compresión y $s(T)$ es el tamaño de la
imagen. $\alpha$ es una constante que se usa para ajustar la importancia que le
damos al tamaño sobre la compresión o vice versa.

Nótese que los dos términos se afectan mutuamente. Una tabla que tiene mayor
compresión va a tener un mayor error, y una tabla con menor compresión resulta
en una imagen de mayor calidad. En otras palabras, cuando el primer término
disminuye, el segundo crece.  Cuando el segundo término crece, el primero
disminuye.

Nuestra meta es encontrar $T$ tal que $f(T)$ es mínima. La relación entre los
dos términos permite que el algoritmo converja.

El primer término es siempre mayor o igual a $1$. A la fracción del segundo
término se le suma 1 porque el valor de $\frac{s(T)}{s(T_0)} \in (0, 1]$. Esto
es puramente una una conveniencia para facilitar la búsqueda de un valor de
$\alpha$ adecuado.

El valor de $\alpha$ controla el proceso de minimización. Mientras mayor sea
$\alpha$, más peso de selección tiene el tamaño de la imagen. El algoritmo tiende
a 'preferir' minimizar el error contra el tamaño después de cierto umbral de
$\alpha > 1$. Para valores de $\alpha \leq 1$, se producen imágenes de muy mala calidad.

Habiendo probado varios valores distintos, se encontró que un valor de $\alpha
= 2$ resulta en imágenes que son indistinguibles de las originales, con un alto
nivel de compresión.


\subsection {Mutación y Reproducción}

Cada generación, sobreviven las dos mejores tablas. El resto se parte en dos.

Con las pruebas que se hicieron, se encontró que con el método de cruza y de
mutación que se está utilizando, la taza más efectiva es dividir 50\% de la
población para ser mutada, y 50\% para ser cruzada. En la mayoría de los casos
esto resultó en una convergencia más rápida con mejores valores al evaluar la
función de selección.

El proceso de mutación es como sigue: Cada entrada de la tabla tiene una
probabilidad de $\frac{1}{64}$ de mutar. Cuando una entrada $e$ muta, lo hace
sumando a su valor original $e_{nueva} = e_{vieja} + x $ donde $x \in [-4, 4]$
con distribución de probabilidad uniforme.

El proceso de reproducción siempre ocurre entre las dos tablas ganadoras. Padre
A y Padre B.  La tabla hijo es el resultado de, para cada entrada, escoger una
entrada de Padre A o de Padre B. La elección es un tiro de moneda. Para alguno
de los dos padres, cada entrada tiene un $50\%$ de probabilidad de venir de él.

\subsection {Fin de la evolución}

El algoritmo decide terminar cuando sucede una de dos cosas:

\begin{itemize}
\item El número de generaciones llega a 100
\item Dado el individuo más apto de generación previa $x_p$ y el de la generación actual, $x_0$, sucede cuatro veces consecutivas que $f(x_p) - f(x_0) \leq 0.0001$, donde $f$ es la función de selección \ref{eq:fitness}.
\end{itemize}

Al final de la evolución, se toma la tabla ganadora y se usa como entrada para
el codificador \gls{JPEG}.

